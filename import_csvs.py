import os
import psycopg2
import pandas as pd
from dotenv import load_dotenv

load_dotenv()

# Debug: Print configuration (without password)
print("üîç Checking configuration...")
print(f"   DB_USER: {os.getenv('DB_USER')}")
print(f"   DB_HOST: {os.getenv('DB_HOST')}")
print(f"   DB_PORT: {os.getenv('DB_PORT', 5432)}")
print(f"   DB_NAME: {os.getenv('DB_NAME')}")
print(f"   DB_PASSWORD: {'*' * len(os.getenv('DB_PASSWORD', '')) if os.getenv('DB_PASSWORD') else 'NOT SET'}")

CSV_DIR = os.getenv("CSV_DIR")

print("\nüîå Attempting to connect to database...")

# === Connect to Neon PostgreSQL via psycopg2 ===
try:
    conn = psycopg2.connect(
        user=os.getenv("DB_USER"),
        password=os.getenv("DB_PASSWORD"),
        host=os.getenv("DB_HOST"),
        port=os.getenv("DB_PORT", 5432),
        database=os.getenv("DB_NAME"),
        sslmode='require'  # Required for Neon
    )
    print("‚úÖ Successfully connected to database!")
except Exception as e:
    print(f"‚ùå Connection failed: {e}")
    print("\nüí° Troubleshooting tips:")
    print("   1. Verify your database credentials in GitHub Secrets")
    print("   2. Ensure credentials don't have extra spaces/newlines")
    print("   3. Check if the Neon database is active (not suspended)")
    print("   4. Verify the user has CONNECT privileges")
    raise

cur = conn.cursor()

# === Helpers ===
def is_intermediate_table(filename):
    base = os.path.splitext(filename)[0]
    return base.isupper()

def truncate_table(cursor, table_name):
    try:
        cursor.execute(f"TRUNCATE TABLE {table_name} RESTART IDENTITY CASCADE;")
        conn.commit()
        print(f"üóëÔ∏è Table {table_name} emptied.")
    except Exception as e:
        print(f"‚ùå Error truncating {table_name}: {e}")
        conn.rollback()

# === Main import loop ===
for file in sorted(os.listdir(CSV_DIR)):
    if not file.endswith(".csv"):
        continue

    table_name = os.path.splitext(file)[0]
    csv_path = os.path.join(CSV_DIR, file)

    # Truncate table first
    truncate_table(cur, table_name)

    print(f"\nüì• Importing {file} ‚Üí table {table_name}...")

    # Read CSV
    df = pd.read_csv(csv_path, sep=";", quotechar='"', escapechar="'")

    # Drop _id for intermediate tables
    if is_intermediate_table(file) and "_id" in df.columns:
        df = df.drop(columns=["_id"])
        print(f"   ‚Ü≥ Dropped '_id' (auto-generated by SERIAL).")

    # Convert Ja/Nee to boolean, except for HAS_PROPERTY
    for col in df.columns:
        if col == "HAS_PROPERTY":
            continue
        if df[col].astype(str).str.lower().isin(["ja", "nee"]).any():
            df[col] = df[col].map(
                lambda x: True if str(x).lower() == "ja" else (False if str(x).lower() == "nee" else None)
            )
            print(f"   ‚Ü≥ Converted 'Ja'/'Nee' to boolean in column '{col}'.")

    # Prepare COPY command
    columns = ','.join(df.columns)
    copy_sql = f"""
        COPY {table_name} ({columns})
        FROM STDIN WITH (FORMAT CSV, DELIMITER ';', QUOTE '"', ESCAPE '''', HEADER TRUE);
    """

    # Write temporary CSV for proper encoding
    tmp_path = os.path.join(CSV_DIR, "_temp.csv")
    df.to_csv(tmp_path, index=False, sep=";", quotechar='"', escapechar="'")

    # Import into PostgreSQL
    with open(tmp_path, "r", encoding="utf-8") as f:
        try:
            cur.copy_expert(copy_sql, f)
            conn.commit()  # Commit after each import
            print(f"‚úÖ Imported {len(df)} rows into {table_name}.")
        except Exception as e:
            print(f"‚ùå Error importing {table_name}: {e}")
            conn.rollback()  # Rollback on error

    os.remove(tmp_path)

# === Close connection ===
cur.close()
conn.close()
print("\nüéâ All CSVs processed successfully!")